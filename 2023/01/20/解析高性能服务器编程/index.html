<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>解析高性能服务器编程</title>
<meta name="keywords" content="解析高性能服务器编程, Tappan">
<meta name="description" content="《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>




  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://trea19.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="http://trea19.github.io">
        <h1 class="site-title">Tappan</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">解析高性能服务器编程</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-01-20</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/socket/">
              socket
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！</p>
<h2 id="Linux-网络编程基础-API"><a href="#Linux-网络编程基础-API" class="headerlink" title="Linux 网络编程基础 API"></a>Linux 网络编程基础 API</h2><h3 id="socket-地址-API"><a href="#socket-地址-API" class="headerlink" title="socket 地址 API"></a>socket 地址 API</h3><p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。</p>
<h4 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h4><p>字节序分为大端字节序(big endian）和小端字节序(little endian)。大端字节序是指一个整数的高位字节(23～31 bit）存储在内存的低地址处，低位字节(0～7bit〉存储在内存的高地址处。小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节存储在内存的地地址处。</p>
<p>当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主村之间直接传递时，接收端必然错误地解释。解决问题的方法是: 发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet/in.h&gt;
unsigned long int htonl ( unsigned long int hostlong );
unsigned short int htons ( unsigned short int hostshort );
unsigned long int ntohl( unsigned long int netlong );
unsigned short int ntohs ( unsigned short int netshort );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如 <code>htonl</code> 表示“host to network long”，即将长整型的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号（当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序）。</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><p>socket网络编程接口中表示 socket地址的结构体定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr{
    sa_family_t sa_family; #地址族类型变量
    char sa_data[14];  #存放socket地址值
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr_storage{
    sa_family_t sa_family;
    unsigned long int __ss_align;  ##内存对齐
    char __ss_padding[128-sizeof(__ss_align)];
} ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>上面这两个通用 socket 地址结构体显然很不好用，比如设置与获取 IP 地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地域协议族使用如下专用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/un.h&gt;
struct sockaddr_un{
	sa_family_t sin_family; #地址族：AF_UNIX
	char sun_path[108]; #文件路径名
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>TCP/IP协议族有sockaddr_in和 sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct sockaddr_in{
    sa_family_t sin_family; #地址族：AF_INET
    u_int16_t sin_port #端口，要用网络字节序表示
	struct in_addr sin_addr; #IPv4地址结构体
};
struct in_addr{
    u_int32_t s_addr; #IPv4地址，用网络字节序表示
};

struct sockaddr_in6{
    sa_family_t sin6_family; #地址族：AF_INET6
    u_int16_t sin6_port; #端口，要用网络字节序表示
    u_int32_t sin6_flowinfo; #流信息，应设置为0
	struct in6_addr sin6_addr; #IPv6地址结构体
    u_int32_t sin6_scope_id; #scope ID 试验阶段
};
struct in6_addr{
    u_int32_t s_addr[16]; #IPv6地址，用网络字节序表示
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注：所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)。</p>
<h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr ( const char* strptr );
int inet_aton ( const char* cp, struct in_addr* inp );
char* inet_ntoa ( struct in_addr in ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>inet_addr</code>函数将用点分十进制字符串表示的 IPv4 地址转化为用网络字节序整数表示的 IPv4 地址。它失败时返回<code>INADDR_NONE</code>。<br><code>inet_aton</code> 函数完成和 inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。<br><code>inet_ntoa</code>函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。</p>
<h3 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>domain: 使用哪个底层协议族， PF_INET 或 PF_INET6 或 PF_UNIx</p>
<p>type: 指定服务类型，SOCK_STREAM(流服务， tcp) 或 SOCK_UGRAM(数据报，udp)</p>
<p>protocol: 在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的，通常设置为0，表示使用默认协议。</p>
<h3 id="命名-socket"><a href="#命名-socket" class="headerlink" title="命名 socket"></a>命名 socket</h3><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket 的系统调用是bind，其定义如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。</p>
<h3 id="监听-socket"><a href="#监听-socket" class="headerlink" title="监听 socket"></a>监听 socket</h3><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int listen(int sockfd, int backlog);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。</p>
<p><del>不行了，进度感人，我要速通！</del></p>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><p>客户端</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭该连接对应的 socket</p>
<p>socket 引用计数减一：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int close(int fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>立即终止 读/写/both：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int shutdown(int sockfd, int howto);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><h4 id="TCP读写"><a href="#TCP读写" class="headerlink" title="TCP读写"></a>TCP读写</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recv(int sockfd, void  *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socken_t* addrlen);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于UDP通信没有连接概念，所以每次读取数据都需要获取发送端的socket地址</p>
<h4 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);
ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">struct msghdr{
	void *msg_name; #socket地址
	socklen_t msg_namelen; #socket地址长度
	struct iovec* msg_iov; #分散的内存块
	int msg_iovlen; #分散内存块数量
	void *msg_control; #指向辅助数据的起始位置
	socklen_t msg_controllen; #辅助数据大小
	int msg_flags; #复制函数中的flags参数，并在调用过程中更新
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sockatmark(int sockfd);  #判断 sockfd 是否处于带外标记<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h3><pre class="line-numbers language-none"><code class="language-none">int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len); 
#获取sockfd对应的本端socket地址
int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);
#获取sockfd对应的远端socket地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><p>读取、设置 socket 文件描述符属性</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsockopt(int sockfd, int level, int option_name, void *option_value, socklen_t* restrict option_len);
int setsockopt(int sockfd, int level, int option_name, const void* option_value, socklen_t option_len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="SO-REUSEADDR-选项"><a href="#SO-REUSEADDR-选项" class="headerlink" title="SO_REUSEADDR 选项"></a>SO_REUSEADDR 选项</h4><p>强制使用被处于 TIME_WAIT 状态的连接占用的 socket 地址。</p>
<h4 id="SO-RCVBUF-和-SO-SNDBUF-选项"><a href="#SO-RCVBUF-和-SO-SNDBUF-选项" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF 选项"></a>SO_RCVBUF 和 SO_SNDBUF 选项</h4><p>TCP接收缓冲区和发送缓冲区大小</p>
<h4 id="SO-RCVLOWAT-和-SO-SNDLOWAT-选项"><a href="#SO-RCVLOWAT-和-SO-SNDLOWAT-选项" class="headerlink" title="SO_RCVLOWAT 和 SO_SNDLOWAT 选项"></a>SO_RCVLOWAT 和 SO_SNDLOWAT 选项</h4><p>TCP接收缓冲区和发送缓冲区的低水位标记。一般被 I/O 复用系统调用，用来判断 socket 是否可读或可写。</p>
<h4 id="SO-LINGER-选项"><a href="#SO-LINGER-选项" class="headerlink" title="SO_LINGER 选项"></a>SO_LINGER 选项</h4><p>控制 close 系统调用在关闭 TCP 连接时的行为。</p>
<h3 id="网络信息-API"><a href="#网络信息-API" class="headerlink" title="网络信息 API"></a>网络信息 API</h3><h4 id="gethostbyname-和-gethostbyaddr"><a href="#gethostbyname-和-gethostbyaddr" class="headerlink" title="gethostbyname 和 gethostbyaddr"></a>gethostbyname 和 gethostbyaddr</h4><p>gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的letc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct hostent* gethostbyname ( const char* name );
struct hostent* gethostbyaddr ( const void* addr, size_t len, int type );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="getservbyname-和-getservbyport"><a href="#getservbyname-和-getservbyport" class="headerlink" title="getservbyname 和 getservbyport"></a>getservbyname 和 getservbyport</h4><p>getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct servent* getservbyname ( const char* name，const char* proto );struct servent* getservbyport ( int port, const char* proto ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是gethostbyname函数)，也能通过服务名获得端口号（内部使用的是getservbyname 函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getaddrinfo( const char* hostname,const char* service,const struct addrinfo* hints, struct addrinfo** result ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><p>getnameinfo 函数能通过 socket 地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnameinfo( const struct sockaddr* sockaddr, socklen_t addrlen, char* host,
socklen_t hostlen, char* serv, socklen_t servlen, int flags );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="高级-I-O-函数"><a href="#高级-I-O-函数" class="headerlink" title="高级 I/O 函数"></a>高级 I/O 函数</h2><p>讨论和网络编程相关的几个，这些函数大致分为三类: 用于创建文件描述符的函数，包括pipe、dup/dup2函数；用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和 tee函数；用于控制I/O行为和属性的函数，包括fcntl函数。</p>
<h3 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe 函数"></a>pipe 函数</h3><p>创建管道，实现进程间通信。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字节流，拥有容量限制</p>
<p>此外，socket的基础API中有一个socketpair 函数。它能够方便地创建双向管道。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int socketpair(int domain, int type,int protocol,int fd[2] );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="dup-函数和-dup2-函数"><a href="#dup-函数和-dup2-函数" class="headerlink" title="dup 函数和 dup2 函数"></a>dup 函数和 dup2 函数</h3><p>把标准输入重定向到一个文件，或把标准输出重定向到一个网络连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dup(int file_descriptor);
int dup2(int file_descriptor_one, int file_descriptor_two);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="readv-函数和-writev-函数"><a href="#readv-函数和-writev-函数" class="headerlink" title="readv 函数和 writev 函数"></a>readv 函数和 writev 函数</h3><p>readv函数将数据从文件描述符读到分散的内存块中，即分散读;writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t readv(int fd, const struct iovec* vector, int count);
ssize_t writev(int fd, const struct iovec* vector, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="sendfile-函数"><a href="#sendfile-函数" class="headerlink" title="sendfile 函数"></a>sendfile 函数</h3><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作)，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t sendfile(int our_fd, int in_fd, off_t* offset, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="mmap-函数和-munmap-函数"><a href="#mmap-函数和-munmap-函数" class="headerlink" title="mmap 函数和 munmap 函数"></a>mmap 函数和 munmap 函数</h3><p>mmap 函数用于申请一段内存空间，可实现进程间共享内存， munmap释放mmap创建的这段内存空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *start, size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="splice-函数"><a href="#splice-函数" class="headerlink" title="splice 函数"></a>splice 函数</h3><p>用于在两个文件描述符之间移动数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h3><p>tee 函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h3><p>filecontrol, 提供了对文件描述符的各种控制操作。</p>
<pre class="line-numbers language-none"><code class="language-none">int fcntl(int fd, int cmd, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="Linux-服务器程序规范"><a href="#Linux-服务器程序规范" class="headerlink" title="Linux 服务器程序规范"></a>Linux 服务器程序规范</h2>
        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-API"><span class="top-box-text">Linux 网络编程基础 API</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#socket-%E5%9C%B0%E5%9D%80-API"><span class="top-box-text">socket 地址 API</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA-socket"><span class="top-box-text">创建 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%91%BD%E5%90%8D-socket"><span class="top-box-text">命名 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%9B%91%E5%90%AC-socket"><span class="top-box-text">监听 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="top-box-text">接受连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="top-box-text">发起连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="top-box-text">关闭连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="top-box-text">数据读写</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="top-box-text">带外标记</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="top-box-text">地址信息函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#socket-%E9%80%89%E9%A1%B9"><span class="top-box-text">socket 选项</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF-API"><span class="top-box-text">网络信息 API</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%AB%98%E7%BA%A7-I-O-%E5%87%BD%E6%95%B0"><span class="top-box-text">高级 I&#x2F;O 函数</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#pipe-%E5%87%BD%E6%95%B0"><span class="top-box-text">pipe 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#dup-%E5%87%BD%E6%95%B0%E5%92%8C-dup2-%E5%87%BD%E6%95%B0"><span class="top-box-text">dup 函数和 dup2 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#readv-%E5%87%BD%E6%95%B0%E5%92%8C-writev-%E5%87%BD%E6%95%B0"><span class="top-box-text">readv 函数和 writev 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#sendfile-%E5%87%BD%E6%95%B0"><span class="top-box-text">sendfile 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mmap-%E5%87%BD%E6%95%B0%E5%92%8C-munmap-%E5%87%BD%E6%95%B0"><span class="top-box-text">mmap 函数和 munmap 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#splice-%E5%87%BD%E6%95%B0"><span class="top-box-text">splice 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#tee%E5%87%BD%E6%95%B0"><span class="top-box-text">tee函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#fcntl-%E5%87%BD%E6%95%B0"><span class="top-box-text">fcntl 函数</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="top-box-text">Linux 服务器程序规范</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/01/12/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">
          <h3 class="post-title">
            下一篇：TCP/IP协议详解
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/Trea19" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

