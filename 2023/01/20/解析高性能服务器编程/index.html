<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>解析高性能服务器编程</title>
<meta name="keywords" content="解析高性能服务器编程, Tappan">
<meta name="description" content="《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>




  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://trea19.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="http://trea19.github.io">
        <h1 class="site-title">Tappan</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">解析高性能服务器编程</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-01-20</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/socket/">
              socket
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！</p>
<h2 id="Linux-网络编程基础-API"><a href="#Linux-网络编程基础-API" class="headerlink" title="Linux 网络编程基础 API"></a>Linux 网络编程基础 API</h2><h3 id="socket-地址-API"><a href="#socket-地址-API" class="headerlink" title="socket 地址 API"></a>socket 地址 API</h3><p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。</p>
<h4 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h4><p>字节序分为大端字节序(big endian）和小端字节序(little endian)。大端字节序是指一个整数的高位字节(23～31 bit）存储在内存的低地址处，低位字节(0～7bit〉存储在内存的高地址处。小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节存储在内存的地地址处。</p>
<p>当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主村之间直接传递时，接收端必然错误地解释。解决问题的方法是: 发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet/in.h&gt;
unsigned long int htonl ( unsigned long int hostlong );
unsigned short int htons ( unsigned short int hostshort );
unsigned long int ntohl( unsigned long int netlong );
unsigned short int ntohs ( unsigned short int netshort );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如 <code>htonl</code> 表示“host to network long”，即将长整型的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号（当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序）。</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><p>socket网络编程接口中表示 socket地址的结构体定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr{
    sa_family_t sa_family; #地址族类型变量
    char sa_data[14];  #存放socket地址值
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr_storage{
    sa_family_t sa_family;
    unsigned long int __ss_align;  ##内存对齐
    char __ss_padding[128-sizeof(__ss_align)];
} ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>上面这两个通用 socket 地址结构体显然很不好用，比如设置与获取 IP 地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地域协议族使用如下专用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/un.h&gt;
struct sockaddr_un{
	sa_family_t sin_family; #地址族：AF_UNIX
	char sun_path[108]; #文件路径名
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>TCP/IP协议族有sockaddr_in和 sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct sockaddr_in{
    sa_family_t sin_family; #地址族：AF_INET
    u_int16_t sin_port #端口，要用网络字节序表示
	struct in_addr sin_addr; #IPv4地址结构体
};
struct in_addr{
    u_int32_t s_addr; #IPv4地址，用网络字节序表示
};

struct sockaddr_in6{
    sa_family_t sin6_family; #地址族：AF_INET6
    u_int16_t sin6_port; #端口，要用网络字节序表示
    u_int32_t sin6_flowinfo; #流信息，应设置为0
	struct in6_addr sin6_addr; #IPv6地址结构体
    u_int32_t sin6_scope_id; #scope ID 试验阶段
};
struct in6_addr{
    u_int32_t s_addr[16]; #IPv6地址，用网络字节序表示
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注：所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)。</p>
<h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr ( const char* strptr );
int inet_aton ( const char* cp, struct in_addr* inp );
char* inet_ntoa ( struct in_addr in ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>inet_addr</code>函数将用点分十进制字符串表示的 IPv4 地址转化为用网络字节序整数表示的 IPv4 地址。它失败时返回<code>INADDR_NONE</code>。<br><code>inet_aton</code> 函数完成和 inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。<br><code>inet_ntoa</code>函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。</p>
<h3 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>domain: 使用哪个底层协议族， PF_INET 或 PF_INET6 或 PF_UNIx</p>
<p>type: 指定服务类型，SOCK_STREAM(流服务， tcp) 或 SOCK_UGRAM(数据报，udp)</p>
<p>protocol: 在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的，通常设置为0，表示使用默认协议。</p>
<h3 id="命名-socket"><a href="#命名-socket" class="headerlink" title="命名 socket"></a>命名 socket</h3><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket 的系统调用是bind，其定义如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。</p>
<h3 id="监听-socket"><a href="#监听-socket" class="headerlink" title="监听 socket"></a>监听 socket</h3><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int listen(int sockfd, int backlog);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。</p>
<p><del>不行了，进度感人，我要速通！</del></p>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><p>客户端</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭该连接对应的 socket</p>
<p>socket 引用计数减一：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int close(int fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>立即终止 读/写/both：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int shutdown(int sockfd, int howto);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><h4 id="TCP读写"><a href="#TCP读写" class="headerlink" title="TCP读写"></a>TCP读写</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recv(int sockfd, void  *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socken_t* addrlen);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于UDP通信没有连接概念，所以每次读取数据都需要获取发送端的socket地址</p>
<h4 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);
ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">struct msghdr{
	void *msg_name; #socket地址
	socklen_t msg_namelen; #socket地址长度
	struct iovec* msg_iov; #分散的内存块
	int msg_iovlen; #分散内存块数量
	void *msg_control; #指向辅助数据的起始位置
	socklen_t msg_controllen; #辅助数据大小
	int msg_flags; #复制函数中的flags参数，并在调用过程中更新
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sockatmark(int sockfd);  #判断 sockfd 是否处于带外标记<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h3><pre class="line-numbers language-none"><code class="language-none">int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len); 
#获取sockfd对应的本端socket地址
int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);
#获取sockfd对应的远端socket地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><p>读取、设置 socket 文件描述符属性</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsockopt(int sockfd, int level, int option_name, void *option_value, socklen_t* restrict option_len);
int setsockopt(int sockfd, int level, int option_name, const void* option_value, socklen_t option_len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="SO-REUSEADDR-选项"><a href="#SO-REUSEADDR-选项" class="headerlink" title="SO_REUSEADDR 选项"></a>SO_REUSEADDR 选项</h4><p>强制使用被处于 TIME_WAIT 状态的连接占用的 socket 地址。</p>
<h4 id="SO-RCVBUF-和-SO-SNDBUF-选项"><a href="#SO-RCVBUF-和-SO-SNDBUF-选项" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF 选项"></a>SO_RCVBUF 和 SO_SNDBUF 选项</h4><p>TCP接收缓冲区和发送缓冲区大小</p>
<h4 id="SO-RCVLOWAT-和-SO-SNDLOWAT-选项"><a href="#SO-RCVLOWAT-和-SO-SNDLOWAT-选项" class="headerlink" title="SO_RCVLOWAT 和 SO_SNDLOWAT 选项"></a>SO_RCVLOWAT 和 SO_SNDLOWAT 选项</h4><p>TCP接收缓冲区和发送缓冲区的低水位标记。一般被 I/O 复用系统调用，用来判断 socket 是否可读或可写。</p>
<h4 id="SO-LINGER-选项"><a href="#SO-LINGER-选项" class="headerlink" title="SO_LINGER 选项"></a>SO_LINGER 选项</h4><p>控制 close 系统调用在关闭 TCP 连接时的行为。</p>
<h3 id="网络信息-API"><a href="#网络信息-API" class="headerlink" title="网络信息 API"></a>网络信息 API</h3><h4 id="gethostbyname-和-gethostbyaddr"><a href="#gethostbyname-和-gethostbyaddr" class="headerlink" title="gethostbyname 和 gethostbyaddr"></a>gethostbyname 和 gethostbyaddr</h4><p>gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的letc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct hostent* gethostbyname ( const char* name );
struct hostent* gethostbyaddr ( const void* addr, size_t len, int type );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="getservbyname-和-getservbyport"><a href="#getservbyname-和-getservbyport" class="headerlink" title="getservbyname 和 getservbyport"></a>getservbyname 和 getservbyport</h4><p>getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct servent* getservbyname ( const char* name，const char* proto );struct servent* getservbyport ( int port, const char* proto ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是gethostbyname函数)，也能通过服务名获得端口号（内部使用的是getservbyname 函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getaddrinfo( const char* hostname,const char* service,const struct addrinfo* hints, struct addrinfo** result ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><p>getnameinfo 函数能通过 socket 地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnameinfo( const struct sockaddr* sockaddr, socklen_t addrlen, char* host,
socklen_t hostlen, char* serv, socklen_t servlen, int flags );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="高级-I-O-函数"><a href="#高级-I-O-函数" class="headerlink" title="高级 I/O 函数"></a>高级 I/O 函数</h2><p>讨论和网络编程相关的几个，这些函数大致分为三类: 用于创建文件描述符的函数，包括pipe、dup/dup2函数；用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和 tee函数；用于控制I/O行为和属性的函数，包括fcntl函数。</p>
<h3 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe 函数"></a>pipe 函数</h3><p>创建管道，实现进程间通信。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字节流，拥有容量限制</p>
<p>此外，socket的基础API中有一个socketpair 函数。它能够方便地创建双向管道。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int socketpair(int domain, int type,int protocol,int fd[2] );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="dup-函数和-dup2-函数"><a href="#dup-函数和-dup2-函数" class="headerlink" title="dup 函数和 dup2 函数"></a>dup 函数和 dup2 函数</h3><p>把标准输入重定向到一个文件，或把标准输出重定向到一个网络连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dup(int file_descriptor);
int dup2(int file_descriptor_one, int file_descriptor_two);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="readv-函数和-writev-函数"><a href="#readv-函数和-writev-函数" class="headerlink" title="readv 函数和 writev 函数"></a>readv 函数和 writev 函数</h3><p>readv函数将数据从文件描述符读到分散的内存块中，即分散读;writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t readv(int fd, const struct iovec* vector, int count);
ssize_t writev(int fd, const struct iovec* vector, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="sendfile-函数"><a href="#sendfile-函数" class="headerlink" title="sendfile 函数"></a>sendfile 函数</h3><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作)，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t sendfile(int our_fd, int in_fd, off_t* offset, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="mmap-函数和-munmap-函数"><a href="#mmap-函数和-munmap-函数" class="headerlink" title="mmap 函数和 munmap 函数"></a>mmap 函数和 munmap 函数</h3><p>mmap 函数用于申请一段内存空间，可实现进程间共享内存， munmap释放mmap创建的这段内存空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *start, size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="splice-函数"><a href="#splice-函数" class="headerlink" title="splice 函数"></a>splice 函数</h3><p>用于在两个文件描述符之间移动数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h3><p>tee 函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h3><p>filecontrol, 提供了对文件描述符的各种控制操作。</p>
<pre class="line-numbers language-none"><code class="language-none">int fcntl(int fd, int cmd, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="Linux-服务器程序规范"><a href="#Linux-服务器程序规范" class="headerlink" title="Linux 服务器程序规范"></a>Linux 服务器程序规范</h2><ul>
<li>后台进程形式运行</li>
<li>有一套日志系统，至少能输出日志到文件</li>
<li>一般以非 root 身份运行</li>
<li>可配置</li>
<li>服务器进程通常会在启动的时候生成一个 PID 文件 </li>
<li>考虑系统资源和限制</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="Linux-系统日志"><a href="#Linux-系统日志" class="headerlink" title="Linux 系统日志"></a>Linux 系统日志</h4><p>守护进程 rsyslogd</p>
<p>rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。</p>
<h4 id="syslog-函数"><a href="#syslog-函数" class="headerlink" title="syslog 函数"></a>syslog 函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void syslog(int priority, const char* message, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="UID、EUID、GID-和-EGID"><a href="#UID、EUID、GID-和-EGID" class="headerlink" title="UID、EUID、GID 和 EGID"></a>UID、EUID、GID 和 EGID</h4><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以root身份运行。下面这一组函数可以获取和设置当前进程的真实用户ID(UID)、有效用户ID （EUID)、真实组ID (GID）和有效组ID(EGID)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uid_t getuid();    /*获取真实用户ID */
uid_t geteuid ();  /*获取有效用户ID */
gid_t getgid ();  /*获取真实组ID*/
gid_t getegid () ; /*获取有效组ID*/
int setuid( uid_t uid ) ;
int seteuid(uid_t uid ) ;
int setgid( gid_t gid ) ;
int setegid(gid_t gid ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>Linux 下每个进程都隶属于一个进程组，获取指定进程的 PGID：</p>
<pre class="line-numbers language-none"><code class="language-none">pid_t getpgid(pid_t pid);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>设置 PGID：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int setpgid(pid_t pid, pid_t pgid);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>一些关联的进程组将形成一个会话（session）</p>
<pre class="line-numbers language-none"><code class="language-none">pid_t setsid(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="用-ps-命令查看进程间关系"><a href="#用-ps-命令查看进程间关系" class="headerlink" title="用 ps 命令查看进程间关系"></a>用 ps 命令查看进程间关系</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-o</span> pid, ppid, pgid, sid, <span class="token function">comm</span> <span class="token operator">|</span> <span class="token function">less</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h3><p>Linux 上运行的程序都会受到资源限制的影响，比如物理设备限制(CPU数量、内存数量等)、系统策略限制（CPU时间等)，以及具体实现的限制（比如文件名的最大长度)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><p>web 服务器的逻辑根目录并非文件系统的根目录”/“, 而是站点的根目录（对于Linux 的web服务器来说， 该目录一般是 /var/www/）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* getcwd(char* buf, size_t size); #获取进程当前工作目录
int chdir(const char* path); #改变进程工作目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h3><p>让一个进程以守护进程的方式运行</p>
<h2 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h2><p>三个主要模块：I/O处理单元， 逻辑单元；存储单元。</p>
<h3 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h3><h4 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h4><p>服务器启动，创建监听socket，bind()绑定到服务器感兴趣的端口，调用listen()等待客户连接。</p>
<p>服务器稳定运行，客户端connect()向服务器发起连接。</p>
<p>由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听。</p>
<h4 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h4><p>peer to peer</p>
<p>主机之间，难互相发现，通常有专门的发现服务器</p>
<h3 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h3><table>
<thead>
<tr>
<th>模块</th>
<th>单个服务器程序</th>
<th>服务器机群</th>
</tr>
</thead>
<tbody><tr>
<td>I/O处理单元</td>
<td>处理客户连接，读写网络程序</td>
<td>作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
<td>逻辑服务器</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>本地数据库、文件或缓存</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
<td>各服务器之间的永久TCP连接</td>
</tr>
</tbody></table>
<h3 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h3><p>socket 在创建时默认是阻塞的。针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。socket 的基础API中，可能被阻塞的系统调用包括accept、send、recv和 connect。</p>
<p>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</p>
<p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等)，才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p>
<p><strong>I/O复用</strong>是最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll和 epoll_wait。I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</p>
<p><strong>SIGIO信号</strong>也可以用来报告I/O事件。可以为一个目标文件描述符指定宿主进程，被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。</p>
<p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。</p>
<p><strong>异步I/O</strong>，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，不论I/O是否是阻塞，因为真正的读写操作已经由内核接管。</p>
<h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：I/O事件、信号、定时事件。</p>
<p>同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现Proactor模式。</p>
<h4 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h4>
        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-API"><span class="top-box-text">Linux 网络编程基础 API</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#socket-%E5%9C%B0%E5%9D%80-API"><span class="top-box-text">socket 地址 API</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA-socket"><span class="top-box-text">创建 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%91%BD%E5%90%8D-socket"><span class="top-box-text">命名 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%9B%91%E5%90%AC-socket"><span class="top-box-text">监听 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="top-box-text">接受连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="top-box-text">发起连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="top-box-text">关闭连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="top-box-text">数据读写</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="top-box-text">带外标记</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="top-box-text">地址信息函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#socket-%E9%80%89%E9%A1%B9"><span class="top-box-text">socket 选项</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF-API"><span class="top-box-text">网络信息 API</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%AB%98%E7%BA%A7-I-O-%E5%87%BD%E6%95%B0"><span class="top-box-text">高级 I&#x2F;O 函数</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#pipe-%E5%87%BD%E6%95%B0"><span class="top-box-text">pipe 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#dup-%E5%87%BD%E6%95%B0%E5%92%8C-dup2-%E5%87%BD%E6%95%B0"><span class="top-box-text">dup 函数和 dup2 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#readv-%E5%87%BD%E6%95%B0%E5%92%8C-writev-%E5%87%BD%E6%95%B0"><span class="top-box-text">readv 函数和 writev 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#sendfile-%E5%87%BD%E6%95%B0"><span class="top-box-text">sendfile 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mmap-%E5%87%BD%E6%95%B0%E5%92%8C-munmap-%E5%87%BD%E6%95%B0"><span class="top-box-text">mmap 函数和 munmap 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#splice-%E5%87%BD%E6%95%B0"><span class="top-box-text">splice 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#tee%E5%87%BD%E6%95%B0"><span class="top-box-text">tee函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#fcntl-%E5%87%BD%E6%95%B0"><span class="top-box-text">fcntl 函数</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="top-box-text">Linux 服务器程序规范</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%97%A5%E5%BF%97"><span class="top-box-text">日志</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="top-box-text">用户信息</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="top-box-text">进程间关系</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="top-box-text">系统资源限制</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="top-box-text">改变工作目录和根目录</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="top-box-text">服务器程序后台化</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="top-box-text">高性能服务器程序框架</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="top-box-text">服务器模型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="top-box-text">服务器编程框架</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#I-O-%E6%A8%A1%E5%9E%8B"><span class="top-box-text">I&#x2F;O 模型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="top-box-text">两种高效的事件处理模式</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/01/12/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">
          <h3 class="post-title">
            下一篇：TCP/IP协议详解
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/Trea19" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

