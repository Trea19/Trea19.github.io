<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>TCP/IP协议详解</title>
<meta name="keywords" content="TCP/IP协议详解, Tappan">
<meta name="description" content="《Linux高性能服务器编程》阅读笔记 part1，在408计网课程的基础上有拓展">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>




  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://trea19.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="http://trea19.github.io">
        <h1 class="site-title">Tappan</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">TCP/IP协议详解</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-01-12</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/TCP-IP/">
              TCP/IP
                
                  ，
                
              </a>
            
              <a href="/tags/webserver/">
              webserver
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>《Linux高性能服务器编程》阅读笔记 part1，在408计网课程的基础上有拓展</p>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。</p>
<p>数据链路层两个常用的协议是ARP协议（Address Resolve Protocol,地址解析协议)和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议)。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换。</p>
<p>ARP协议将目标机器的IP地址转化成其物理地址。</p>
<p>RARP协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层实现数据包的选路和转发。WAN (Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN(Local Area Network，局域网)。</p>
<p>IP协议(Internet Protocol，因特网协议) ：根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳(next hop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程（hop by hop），数据包最终到达目标主机，或者由于发送失败而被丢弃。</p>
<p>ICMP协议(Internet Control Message Protocol，因特网控制报文协议) 是IP协议的重要补充，主要用于检测网络连接。</p>
<p>8位类型字段用于区分报文类型。它将ICMP报文分为两大类: 一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5); 另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。</p>
<p>ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验(Cyclic Redundancy Check，CRC)。</p>
<p>注：ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（-一般来说，上层协议使用下层协议提供的服务)。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为两台主机上的应用程序提供端到端(end to end）的通信</p>
<p>传输层为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。</p>
<p>传输层协议主要有三个: TCP协议、UDP协议和SCTP协议。</p>
<p>TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的面向连接的和基于流的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。</p>
<p>UDP协议（User Datagram Protocol，用户数据报协议）为应用层提供不可靠、无连接和基于数据报的服务。UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息)。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</p>
<p>SCTP协议(Stream Control Transmission Protocol，流控制传输协议〉是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现。应用层负责处理应用程序的逻辑，在用户空间实现。</p>
<p>应用层协议很多，图1-1仅列举了其中的几个:</p>
<p>ping是应用程序，而不是协议，它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<p>telnet协议是一种远程登录协议，它使我们能在本地完成远程任务。</p>
<p>OSPF (Open Shortest Path First，开放最短路径优先〉协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<p>DNS ( Domain Name Service，域名服务）协议提供机器域名到IP地址的转换。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>TCP封装</p>
<p>当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
<p>UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃。</p>
<p>IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。</p>
<p>经过数据链路层封装的数据称为帧（ frame)。帧的最大传输单元(Max Transmit Unit，MTU)，即帧最多能携带多少上层协议数据(比如IP数据报)，通常受到网络类型的限制。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用(demultiplexing)。分用是依靠头部信息中的类型字段实现的。</p>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。</p>
<p>同样，因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（ protocol）字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number）字段来区分上层应用程序。Linux可以在<code>etc/services</code>找到知名应用层协议的端口号。</p>
<h2 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h2><h3 id="ARP高速缓存的查看与修改"><a href="#ARP高速缓存的查看与修改" class="headerlink" title="ARP高速缓存的查看与修改"></a>ARP高速缓存的查看与修改</h3><pre class="line-numbers language-none"><code class="language-none">apt install net-tools
arp -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sudo arp -d 192.168.1.109 //删除该IP对应的ARP缓存
sudo arp -s 192.168.1.109 08:00:27:53:10:67 //添加<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="使用tcpdump观察ARP通信"><a href="#使用tcpdump观察ARP通信" class="headerlink" title="使用tcpdump观察ARP通信"></a>使用tcpdump观察ARP通信</h3><pre class="line-numbers language-none"><code class="language-none">sudo arp -d 192.168.1.109 //删除该IP对应的ARP缓存
sudo tcpdump -i eth0 -ent '(dst 192.168.1.109 and src 192.168.1.108)' //抓包在108对应的主机上进行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>另一个终端</p>
<pre class="line-numbers language-none"><code class="language-none">telnet 192.168.1.109 echo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h2><p>DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>
<h3 id="Linux-下访问DNS服务器"><a href="#Linux-下访问DNS服务器" class="headerlink" title="Linux 下访问DNS服务器"></a>Linux 下访问DNS服务器</h3><p>linux使用<code>/etc/resolv.conf</code>文件存放DNS服务器IP地址</p>
<pre class="line-numbers language-none"><code class="language-none">host -t A www.baidu.com //查看别名和ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="使用tcpdump观察DNS通信过程"><a href="#使用tcpdump观察DNS通信过程" class="headerlink" title="使用tcpdump观察DNS通信过程"></a>使用tcpdump观察DNS通信过程</h3><pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -i eth0 -nt -s 500 port domain
host -t A www.buidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="socket-和-TCP-IP-协议族关系"><a href="#socket-和-TCP-IP-协议族关系" class="headerlink" title="socket 和 TCP/IP 协议族关系"></a>socket 和 TCP/IP 协议族关系</h2><p>数据链路层、网络层、传输层协议是在内核中实现的，因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务，实现这组系统调用的API(Application Programming Interface，应用程序编程接口）主要有两套: socket和 XTI。</p>
<p>由socket定义的这一组API提供如下两点功能:</p>
<p>一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据（比，或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；</p>
<p>二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如可以通过setsockopt 函数来设置IP数据报在网络上的存活时间。</p>
<h2 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h2><h3 id="IP服务的特点"><a href="#IP服务的特点" class="headerlink" title="IP服务的特点"></a>IP服务的特点</h3><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
<p>无状态( stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。接收端的IP模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组)，就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。</p>
<p>无连接(connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力( best effort)。发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h3 id="使用tcpdump观察IPv4头部结构"><a href="#使用tcpdump观察IPv4头部结构" class="headerlink" title="使用tcpdump观察IPv4头部结构"></a>使用tcpdump观察IPv4头部结构</h3><pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -ntx -i lo //抓取本地回路上的数据包
telnet 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。</p>
<p>用tcpdump抓取ICMP报文（看分片</p>
<pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -ntv -i eth0 icmp  //只抓ICMP报文
ping XXXX -s 1473  //-s选项指定每次发送1473字节数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><h4 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h4><p>使用<code>route</code>或<code>netstat</code>命令查看路由表</p>
<h4 id="路由表更新"><a href="#路由表更新" class="headerlink" title="路由表更新"></a>路由表更新</h4><p>route 命令可以修改路由表(静态路由更新)</p>
<pre class="line-numbers language-none"><code class="language-none">sudo route add -host 192.168.1.109 dev eth0
sudo route del -net 192.168.1.0 netmask 255.255.255.0
sudo route del default
sudo route add default gw 192.168.1.109 dev eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态更新：通常通过BGP (Border Gateway Protocol，边际网关协议)、RIP(Routing Information Protocol，路由信息协议)、OSPF等协议来发现路径，并更新自己的路由表。</p>
<h3 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h3><p>使能主机的数据报转发功能</p>
<pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; /proc/sys/net/ipv4/ip_forward<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于允许IP数据报转发的系统（主机或路由器)，数据报转发子模块将对期望转发的数据报执行如下操作:<br>1）检查数据报头部的TTL值。如果 TTL值已经是0，则丢弃该数据报。<br>2）查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。<br>3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。<br>4）将TTL值减1。<br>5）处理IP头部选项。<br>6）如果有必要，则执行IP分片操作。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="ICMP重定向报文"><a href="#ICMP重定向报文" class="headerlink" title="ICMP重定向报文"></a>ICMP重定向报文</h4><p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息:引起重定向的IP数据报的源端IP地址。应该使用的路由器的IP地址。<br>接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表)。</p>
<h3 id="IPv6头部结构"><a href="#IPv6头部结构" class="headerlink" title="IPv6头部结构"></a>IPv6头部结构</h3><p>IPv6协议是网络层技术发展的必然趋势。它不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如，增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便﹔增加了专门的网络安全功能等。</p>
<h2 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h2><h3 id="TCP服务的特点"><a href="#TCP服务的特点" class="headerlink" title="TCP服务的特点"></a>TCP服务的特点</h3><p>面向连接、字节流、可靠传输</p>
<p>全双工、一对一</p>
<p>发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是<strong>字节流</strong>的概念: 应用程序对数据的发送和接收是没有边界限制的。</p>
<p>UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调用)，否则就会丢包。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。</p>
<p><strong>可靠</strong>：发送应答机制、超时重传、重排整理后交付应用层。</p>
<h3 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h3><h4 id="TCP头部选项"><a href="#TCP头部选项" class="headerlink" title="TCP头部选项"></a>TCP头部选项</h4><p>7种常见的TCP头部选项</p>
<p>kind=0是选项表结束选项。</p>
<p>kind=1是空操作〈nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind=2是最大报文段长度选项。TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS)。TCP模块通常将MSS设置为(MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部)。</p>
<p>kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65 535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量)。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数〉是M，那么TCP报文段的实际接收通告窗口大小是N乘2“，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改<code>/proc/sys/net/ipv4/tcp window_scaling</code> 内核变量来启用或关闭窗口扩大因子选项。</p>
<p>kind=4是选择性确认(Selective Acknowledgment，SACK) 选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK 技术。我们可以通过修改<code>/proc/sys/net/ipv4/tcp_sack</code>内核变量来启用或关闭选择性确认选项。</p>
<p>kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block)参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。</p>
<p>kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间( Round Trip Time，RTT)的方法，从而为TCP流量控制提供重要信息。我们可以通过修改<code>/proc/sys!net/ipv4/tcp_timestamps</code> 内核变量来启用或关闭时间戳选项。.</p>
<h3 id="TCP连接的建立和关闭"><a href="#TCP连接的建立和关闭" class="headerlink" title="TCP连接的建立和关闭"></a>TCP连接的建立和关闭</h3><h4 id="使用tcpdump观察TCP连接的建立和关闭"><a href="#使用tcpdump观察TCP连接的建立和关闭" class="headerlink" title="使用tcpdump观察TCP连接的建立和关闭"></a>使用tcpdump观察TCP连接的建立和关闭</h4><pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -i eth0 -nt '(src 192.168.1.109 and dst 192.168.1.108) or (src 192.168.1.108 and dst 192.168.1.109)'
telnet 192.168.1.109 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>TCP三次握手+四次挥手</p>
<h4 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h4><p>使用半关闭的应用程序很少见（</p>
<h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p>模拟超时：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo iptables -F
sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>iptable命令用于过滤数据包，这里我们利用它来丢弃所有接收到的连接请求（丢弃所有同步报文段，这样客户端就无法得到任何确认报文段)。</p>
<p>在另一台主机</p>
<pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -n -i eth0 port 23   #仅抓取telnet客户端和服务端交换的数据包
date; telnet 192.168.1.108; date   #在telnet命令前后都执行date命令，计算超时时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h3><p>当前状态可以通过 <code>netstat</code> 查看</p>
<h4 id="TCP状态转移总图"><a href="#TCP状态转移总图" class="headerlink" title="TCP状态转移总图"></a>TCP状态转移总图</h4><p><img src="/images/tcp-2.jpg" alt="tcp-2"></p>
<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>客户端连接在收到服务器的结束报文段之后，并没有直接进人CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段长为2MSL的时间，才能完全关闭。</p>
<p>TIME_WAIT状态存在的原因有两点: 可靠地终止TCP连接；保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p>
<p>一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据。</p>
<p>当然，对客户端程序来说，我们通常不用担心上面描述的重启问题。因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性，临时端口号一般和程序上一次使用的端口号（还处于TIME_WAIT状念）不同。</p>
<p>但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，我们可以通过socket选项<code>SO_REUSEADDR</code>来强制进程立即使用处于TIME_WAIT状态的连接占用的端口。</p>
<h3 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h3><p>携带RST标志的报文段，通知对方关闭连接或重新建立连接。</p>
<h4 id="访问不存在的端口"><a href="#访问不存在的端口" class="headerlink" title="访问不存在的端口"></a>访问不存在的端口</h4><p>略</p>
<h4 id="异常终止连接"><a href="#异常终止连接" class="headerlink" title="异常终止连接"></a>异常终止连接</h4><p>前面讨论的连接终止方式都是正常的终止方式: 数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。<br>应用程序可以使用socket选项<code>SO_LINGER</code>来发送复位报文段，以异常终止一个连接。</p>
<h4 id="处理半打开连接"><a href="#处理半打开连接" class="headerlink" title="处理半打开连接"></a>处理半打开连接</h4><p>服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障)，此时，客户端（或服务器）还维持着原来的连接，而服务器(或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。</p>
<h3 id="TCP交互-成块数据流"><a href="#TCP交互-成块数据流" class="headerlink" title="TCP交互/成块数据流"></a>TCP交互/成块数据流</h3><p>TCP报文段所携带的应用程序数据按照长度分为两种: 交互数据和成块数据。</p>
<p>交互数据仅包含很少的字节，使用交互数据的应用程序（或协议）对实时性要求高，比如 telnet、ssh等。成块数据的长度则通常为TCP报文段允许的最大数据长度，使用成块数据的应用程序(或协议〉对传输效率要求高，比如 ftp。</p>
<h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><p>有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）有更高的优先级，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序。</p>
<p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急数据称为带外数据。</p>
<h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>略</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分: 慢启动 (slow start)、拥塞避免(congestion avoidance)、快速重传（fast retransmit）和快速恢复（fastrecovery)。<code>/proc/sys/net/ipv4/tcp_congestion_control</code> 文件指示机器当前所使用的拥塞控制算法。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，我们称为SWND (Send Window，发送窗口)。接收方可通过其接收通告窗口(RWND）来控制发送端的SWND，但这显然不够，所以发送端引入了一个称为拥塞窗口 (Congestion Window，CWND）的状态变量。实际的SWND值是RWND和CWND中的较小者。</p>
<p>发送端判断拥塞发生的依据有如下两个: 传输超时，或者说TCP重传定时器溢出；接收到重复的确认报文段。</p>
<p>拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复（如果是真的发生拥塞的话)，这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p>
<h2 id="访问-Internet-上的-Web-服务器"><a href="#访问-Internet-上的-Web-服务器" class="headerlink" title="访问 Internet 上的 Web 服务器"></a>访问 Internet 上的 Web 服务器</h2><h3 id="HTTP-代理服务器的工作原理"><a href="#HTTP-代理服务器的工作原理" class="headerlink" title="HTTP 代理服务器的工作原理"></a>HTTP 代理服务器的工作原理</h3><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多个代理服务器转发，后面的服务器称为前面服务器的上游服务器。代理服务器按照其使用方式和作用，分为正向代理服务器、反向代理服务器和透明代理服务器。</p>
<p>正向代理要求客户端自己设置代理服务器的地址。客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用正向代理服务器。</p>
<p>反向代理则被设置在服务器端，因而客户端无须进行任何设置。反向代理是指用代理服务器来接收Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同-个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。图4-2显示了正向代理服务器和反向代理服务器在HTTP通信链上的逻辑位置。</p>
<p>透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况。</p>
<h3 id="访问DNS服务器"><a href="#访问DNS服务器" class="headerlink" title="访问DNS服务器"></a>访问DNS服务器</h3><p>squid程序通过读取<code>letc/resolv.conf</code>文件获得 DNS 服务器的 IP 地址，然后将控制权传递给内核中的 UDP 模块。UDP 模块将 DNS 查询报文封装成 UDP 数据报，同时把源端口号和目标端口号加入 UDP 数据报头部，然后UDP模块调用 IP 服务。</p>
<p>IP 模块则将 UDP 数据报封装成 IP 数据报，并把源端 IP 地址和 DNS 服务器的 IP 地址加人 IP 数据报头部。接下来，IP模块查询路由表以决定如何发送该IP数据报。</p>
<p>因为ernest-laptop 的ARP缓存中没有与路由器对应的缓存项（手动将其删除了)，所以ernest-laptop需要发起一个ARP 广播以查询路由器的 IP 地址。路由器则通过 ARP 应答告诉ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78 。最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器。此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了路由器的IP地址和 MAC地址的映射关系。</p>
<p>注：虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务器）的IP地址，而不是中转路由器的IP地址。</p>
<h3 id="本地名称查询"><a href="#本地名称查询" class="headerlink" title="本地名称查询"></a>本地名称查询</h3><p>一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。<br>Linux将目标主机名及其对应的IP地址存储在<code>letc/hosts</code>配置文件中。</p>
<p>当wget访问某个Web服务器时，它先读取环境变量<code>http_proxy</code>。如果该环境变量被设置，并且我们没有阻止 wget使用代理服务，则wget将通过<code>http_proxy</code>指定的代理服务器来访问Web服务。但<code>http_proxy</code>环境变量中包含主机名ernest-laptop，因此 wget将首先读取<code>etc/hosts</code> 配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。</p>
<h3 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h3><pre class="line-numbers language-none"><code class="language-none">GET http://www.baidu.com/index.html HTTP/1.0
User-Agent: wget/ 1.12 (linux-gnu)
Host: www.baidu.com
Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/images/http1.jpg" alt="http1"></p>
<h3 id="HTTP应答"><a href="#HTTP应答" class="headerlink" title="HTTP应答"></a>HTTP应答</h3><pre class="line-numbers language-none"><code class="language-none">HTTP/1.0 200 oK
Server: BWS /1.0
Content-Length: 8024
Content-Type: text/html;charset =gbk
Set-Cookie: BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1; expires=Wed,04 -Jul-42 00:10:47 GMT; path=/; domain=.baidu.com
Via: 1.0 localhost (squid/ 3.0 STABLE18)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>HTTP状态码</p>
<p><img src="/images/http2.png" alt="http2"></p>
<p><code>Server: BWS/1.0</code> 表示目标Web服务器程序的名字是BwS (Baidu Web Server)。<br><code>Content-Length:8024</code> 表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。<br><code>Content-Type: text/html;charset =gbk</code> 表示目标文档的MIME类型。其中“text”是主文档类型，“html”是子文档类型。”“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。<br><code>Set-Cookie: BAIDUID=ASB6C72D68CF639CE8896FD79A03FBD8:FG=1; expires=Wed, 04-Jul-42 00:10:47 GMT; path=/; domain=.baidu.com</code> 表示服务器传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie生效的域名和路径。<br><code>Via: 1.0 localhost (squid/3.0 STABLE18)</code> 表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的 localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由功能。</p>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="top-box-text">TCP&#x2F;IP协议族</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="top-box-text">数据链路层</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="top-box-text">网络层</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="top-box-text">传输层</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="top-box-text">应用层</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B0%81%E8%A3%85"><span class="top-box-text">封装</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%88%86%E7%94%A8"><span class="top-box-text">分用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="top-box-text">ARP协议工作原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ARP%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="top-box-text">ARP高速缓存的查看与修改</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FARP%E9%80%9A%E4%BF%A1"><span class="top-box-text">使用tcpdump观察ARP通信</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#DNS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="top-box-text">DNS工作原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Linux-%E4%B8%8B%E8%AE%BF%E9%97%AEDNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="top-box-text">Linux 下访问DNS服务器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FDNS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="top-box-text">使用tcpdump观察DNS通信过程</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#socket-%E5%92%8C-TCP-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%85%B3%E7%B3%BB"><span class="top-box-text">socket 和 TCP&#x2F;IP 协议族关系</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="top-box-text">IP协议详解</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="top-box-text">IP服务的特点</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BD%BF%E7%94%A8tcpdump%E8%A7%82%E5%AF%9FIPv4%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="top-box-text">使用tcpdump观察IPv4头部结构</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%86%E7%89%87"><span class="top-box-text">分片</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IP%E8%B7%AF%E7%94%B1"><span class="top-box-text">IP路由</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IP%E8%BD%AC%E5%8F%91"><span class="top-box-text">IP转发</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="top-box-text">重定向</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IPv6%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="top-box-text">IPv6头部结构</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="top-box-text">TCP协议详解</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="top-box-text">TCP服务的特点</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="top-box-text">TCP头部结构</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD"><span class="top-box-text">TCP连接的建立和关闭</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="top-box-text">TCP状态转移</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%8D%E4%BD%8D%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="top-box-text">复位报文段</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E4%BA%A4%E4%BA%92-%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="top-box-text">TCP交互&#x2F;成块数据流</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="top-box-text">带外数据</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="top-box-text">TCP超时重传</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="top-box-text">拥塞控制</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%AE%BF%E9%97%AE-Internet-%E4%B8%8A%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="top-box-text">访问 Internet 上的 Web 服务器</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#HTTP-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="top-box-text">HTTP 代理服务器的工作原理</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AE%BF%E9%97%AEDNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="top-box-text">访问DNS服务器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9C%AC%E5%9C%B0%E5%90%8D%E7%A7%B0%E6%9F%A5%E8%AF%A2"><span class="top-box-text">本地名称查询</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#HTTP%E9%80%9A%E4%BF%A1"><span class="top-box-text">HTTP通信</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#HTTP%E5%BA%94%E7%AD%94"><span class="top-box-text">HTTP应答</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/posts/b65a1481.html">
          <h3 class="post-title">
            下一篇：CMU15445-2022 环境配置
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/Trea19" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

