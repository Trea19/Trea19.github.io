<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>解析高性能服务器编程</title>
<meta name="keywords" content="解析高性能服务器编程, Tappan">
<meta name="description" content="《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>




  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://trea19.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="http://trea19.github.io">
        <h1 class="site-title">Tappan</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">解析高性能服务器编程</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-01-20</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/webserver/">
              webserver
                
                  ，
                
              </a>
            
              <a href="/tags/socket/">
              socket
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>《Linux高性能服务器编程》阅读笔记 part2，一起入门网络编程吧！</p>
<p>这篇 notes 篇幅较长，所以在前边加个<strong>目录</strong></p>
<!-- toc -->

<ul>
<li><a href="#linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-api">Linux 网络编程基础 API</a><ul>
<li><a href="#socket-%E5%9C%B0%E5%9D%80-api">socket 地址 API</a><ul>
<li><a href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F">主机字节序和网络字节序</a></li>
<li><a href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80">通用socket地址</a></li>
<li><a href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80">专用socket地址</a></li>
<li><a href="#ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">IP地址转换函数</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA-socket">创建 socket</a></li>
<li><a href="#%E5%91%BD%E5%90%8D-socket">命名 socket</a></li>
<li><a href="#%E7%9B%91%E5%90%AC-socket">监听 socket</a></li>
<li><a href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5">接受连接</a></li>
<li><a href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5">发起连接</a></li>
<li><a href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5">关闭连接</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99">数据读写</a><ul>
<li><a href="#tcp%E8%AF%BB%E5%86%99">TCP读写</a></li>
<li><a href="#udp%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99">UDP数据读写</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0">通用数据读写函数</a></li>
</ul>
</li>
<li><a href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0">带外标记</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0">地址信息函数</a></li>
<li><a href="#socket-%E9%80%89%E9%A1%B9">socket 选项</a><ul>
<li><a href="#so_reuseaddr-%E9%80%89%E9%A1%B9">SO_REUSEADDR 选项</a></li>
<li><a href="#so_rcvbuf-%E5%92%8C-so_sndbuf-%E9%80%89%E9%A1%B9">SO_RCVBUF 和 SO_SNDBUF 选项</a></li>
<li><a href="#so_rcvlowat-%E5%92%8C-so_sndlowat-%E9%80%89%E9%A1%B9">SO_RCVLOWAT 和 SO_SNDLOWAT 选项</a></li>
<li><a href="#so_linger-%E9%80%89%E9%A1%B9">SO_LINGER 选项</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF-api">网络信息 API</a><ul>
<li><a href="#gethostbyname-%E5%92%8C-gethostbyaddr">gethostbyname 和 gethostbyaddr</a></li>
<li><a href="#getservbyname-%E5%92%8C-getservbyport">getservbyname 和 getservbyport</a></li>
<li><a href="#getaddrinfo">getaddrinfo</a></li>
<li><a href="#getnameinfo">getnameinfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%BA%A7-io-%E5%87%BD%E6%95%B0">高级 I/O 函数</a><ul>
<li><a href="#pipe-%E5%87%BD%E6%95%B0">pipe 函数</a></li>
<li><a href="#dup-%E5%87%BD%E6%95%B0%E5%92%8C-dup2-%E5%87%BD%E6%95%B0">dup 函数和 dup2 函数</a></li>
<li><a href="#readv-%E5%87%BD%E6%95%B0%E5%92%8C-writev-%E5%87%BD%E6%95%B0">readv 函数和 writev 函数</a></li>
<li><a href="#sendfile-%E5%87%BD%E6%95%B0">sendfile 函数</a></li>
<li><a href="#mmap-%E5%87%BD%E6%95%B0%E5%92%8C-munmap-%E5%87%BD%E6%95%B0">mmap 函数和 munmap 函数</a></li>
<li><a href="#splice-%E5%87%BD%E6%95%B0">splice 函数</a></li>
<li><a href="#tee%E5%87%BD%E6%95%B0">tee函数</a></li>
<li><a href="#fcntl-%E5%87%BD%E6%95%B0">fcntl 函数</a></li>
</ul>
</li>
<li><a href="#linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83">Linux 服务器程序规范</a><ul>
<li><a href="#%E6%97%A5%E5%BF%97">日志</a><ul>
<li><a href="#linux-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97">Linux 系统日志</a></li>
<li><a href="#syslog-%E5%87%BD%E6%95%B0">syslog 函数</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">用户信息</a><ul>
<li><a href="#uid-euid-gid-%E5%92%8C-egid">UID、EUID、GID 和 EGID</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB">进程间关系</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%BB%84">进程组</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D">会话</a></li>
<li><a href="#%E7%94%A8-ps-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB">用 ps 命令查看进程间关系</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">系统资源限制</a></li>
<li><a href="#%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95">改变工作目录和根目录</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96">服务器程序后台化</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6">高性能服务器程序框架</a><ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B">服务器模型</a><ul>
<li><a href="#cs%E6%A8%A1%E5%9E%8B">C/S模型</a></li>
<li><a href="#p2p-%E6%A8%A1%E5%9E%8B">P2P 模型</a></li>
</ul>
</li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6">服务器编程框架</a></li>
<li><a href="#io-%E6%A8%A1%E5%9E%8B">I/O 模型</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F">两种高效的事件处理模式</a><ul>
<li><a href="#reactor-%E6%A8%A1%E5%BC%8F">Reactor 模式</a></li>
<li><a href="#proactor-%E6%A8%A1%E5%BC%8F">Proactor 模式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F">两种高效的并发模式</a><ul>
<li><a href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F">半同步/半异步模式</a></li>
<li><a href="#%E9%A2%86%E5%AF%BC%E8%80%85%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F">领导者/追随者模式</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E6%95%88%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">高效的逻辑处理方式</a></li>
<li><a href="#%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE">提高服务器编程的其他建议</a><ul>
<li><a href="#%E6%B1%A0">池</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6">数据复制</a></li>
<li><a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%92%8C%E9%94%81">上下文切换和锁</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#io-%E5%A4%8D%E7%94%A8">I/O 复用</a></li>
</ul>
<!-- tocstop -->

<h2><span id="linux-网络编程基础-api">Linux 网络编程基础 API</span></h2><h3><span id="socket-地址-api">socket 地址 API</span></h3><p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。</p>
<h4><span id="主机字节序和网络字节序">主机字节序和网络字节序</span></h4><p>字节序分为大端字节序(big endian）和小端字节序(little endian)。大端字节序是指一个整数的高位字节(23～31 bit）存储在内存的低地址处，低位字节(0～7bit〉存储在内存的高地址处。小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节存储在内存的地地址处。</p>
<p>当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主村之间直接传递时，接收端必然错误地解释。解决问题的方法是: 发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet/in.h&gt;
unsigned long int htonl ( unsigned long int hostlong );
unsigned short int htons ( unsigned short int hostshort );
unsigned long int ntohl( unsigned long int netlong );
unsigned short int ntohs ( unsigned short int netshort );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如 <code>htonl</code> 表示“host to network long”，即将长整型的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号（当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序）。</p>
<h4><span id="通用socket地址">通用socket地址</span></h4><p>socket网络编程接口中表示 socket地址的结构体定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr{
    sa_family_t sa_family; #地址族类型变量
    char sa_data[14];  #存放socket地址值
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/socket.h&gt;
struct sockaddr_storage{
    sa_family_t sa_family;
    unsigned long int __ss_align;  ##内存对齐
    char __ss_padding[128-sizeof(__ss_align)];
} ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4><span id="专用socket地址">专用socket地址</span></h4><p>上面这两个通用 socket 地址结构体显然很不好用，比如设置与获取 IP 地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地域协议族使用如下专用socket地址结构体:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/un.h&gt;
struct sockaddr_un{
	sa_family_t sin_family; #地址族：AF_UNIX
	char sun_path[108]; #文件路径名
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>TCP/IP协议族有sockaddr_in和 sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct sockaddr_in{
    sa_family_t sin_family; #地址族：AF_INET
    u_int16_t sin_port #端口，要用网络字节序表示
	struct in_addr sin_addr; #IPv4地址结构体
};
struct in_addr{
    u_int32_t s_addr; #IPv4地址，用网络字节序表示
};

struct sockaddr_in6{
    sa_family_t sin6_family; #地址族：AF_INET6
    u_int16_t sin6_port; #端口，要用网络字节序表示
    u_int32_t sin6_flowinfo; #流信息，应设置为0
	struct in6_addr sin6_addr; #IPv6地址结构体
    u_int32_t sin6_scope_id; #scope ID 试验阶段
};
struct in6_addr{
    u_int32_t s_addr[16]; #IPv6地址，用网络字节序表示
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注：所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)。</p>
<h4><span id="ip地址转换函数">IP地址转换函数</span></h4><p>下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr ( const char* strptr );
int inet_aton ( const char* cp, struct in_addr* inp );
char* inet_ntoa ( struct in_addr in ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>inet_addr</code>函数将用点分十进制字符串表示的 IPv4 地址转化为用网络字节序整数表示的 IPv4 地址。它失败时返回<code>INADDR_NONE</code>。<br><code>inet_aton</code> 函数完成和 inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。<br><code>inet_ntoa</code>函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。</p>
<h3><span id="创建-socket">创建 socket</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>domain: 使用哪个底层协议族， PF_INET 或 PF_INET6 或 PF_UNIx</p>
<p>type: 指定服务类型，SOCK_STREAM(流服务， tcp) 或 SOCK_UGRAM(数据报，udp)</p>
<p>protocol: 在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的，通常设置为0，表示使用默认协议。</p>
<h3><span id="命名-socket">命名 socket</span></h3><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket 的系统调用是bind，其定义如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。</p>
<h3><span id="监听-socket">监听 socket</span></h3><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int listen(int sockfd, int backlog);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。</p>
<p><del>不行了，进度感人，我要速通！</del></p>
<h3><span id="接受连接">接受连接</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="发起连接">发起连接</span></h3><p>客户端</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="关闭连接">关闭连接</span></h3><p>关闭该连接对应的 socket</p>
<p>socket 引用计数减一：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int close(int fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>立即终止 读/写/both：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int shutdown(int sockfd, int howto);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="数据读写">数据读写</span></h3><h4><span id="tcp读写">TCP读写</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recv(int sockfd, void  *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4><span id="udp数据读写">UDP数据读写</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socken_t* addrlen);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于UDP通信没有连接概念，所以每次读取数据都需要获取发送端的socket地址</p>
<h4><span id="通用数据读写函数">通用数据读写函数</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);
ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">struct msghdr{
	void *msg_name; #socket地址
	socklen_t msg_namelen; #socket地址长度
	struct iovec* msg_iov; #分散的内存块
	int msg_iovlen; #分散内存块数量
	void *msg_control; #指向辅助数据的起始位置
	socklen_t msg_controllen; #辅助数据大小
	int msg_flags; #复制函数中的flags参数，并在调用过程中更新
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3><span id="带外标记">带外标记</span></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sockatmark(int sockfd);  #判断 sockfd 是否处于带外标记<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3><span id="地址信息函数">地址信息函数</span></h3><pre class="line-numbers language-none"><code class="language-none">int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len); 
#获取sockfd对应的本端socket地址
int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);
#获取sockfd对应的远端socket地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3><span id="socket-选项">socket 选项</span></h3><p>读取、设置 socket 文件描述符属性</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsockopt(int sockfd, int level, int option_name, void *option_value, socklen_t* restrict option_len);
int setsockopt(int sockfd, int level, int option_name, const void* option_value, socklen_t option_len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4><span id="so_reuseaddr-选项">SO_REUSEADDR 选项</span></h4><p>强制使用被处于 TIME_WAIT 状态的连接占用的 socket 地址。</p>
<h4><span id="so_rcvbuf-和-so_sndbuf-选项">SO_RCVBUF 和 SO_SNDBUF 选项</span></h4><p>TCP接收缓冲区和发送缓冲区大小</p>
<h4><span id="so_rcvlowat-和-so_sndlowat-选项">SO_RCVLOWAT 和 SO_SNDLOWAT 选项</span></h4><p>TCP接收缓冲区和发送缓冲区的低水位标记。一般被 I/O 复用系统调用，用来判断 socket 是否可读或可写。</p>
<h4><span id="so_linger-选项">SO_LINGER 选项</span></h4><p>控制 close 系统调用在关闭 TCP 连接时的行为。</p>
<h3><span id="网络信息-api">网络信息 API</span></h3><h4><span id="gethostbyname-和-gethostbyaddr">gethostbyname 和 gethostbyaddr</span></h4><p>gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的letc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct hostent* gethostbyname ( const char* name );
struct hostent* gethostbyaddr ( const void* addr, size_t len, int type );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4><span id="getservbyname-和-getservbyport">getservbyname 和 getservbyport</span></h4><p>getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct servent* getservbyname ( const char* name，const char* proto );struct servent* getservbyport ( int port, const char* proto ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4><span id="getaddrinfo">getaddrinfo</span></h4><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是gethostbyname函数)，也能通过服务名获得端口号（内部使用的是getservbyname 函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getaddrinfo( const char* hostname,const char* service,const struct addrinfo* hints, struct addrinfo** result ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4><span id="getnameinfo">getnameinfo</span></h4><p>getnameinfo 函数能通过 socket 地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnameinfo( const struct sockaddr* sockaddr, socklen_t addrlen, char* host,
socklen_t hostlen, char* serv, socklen_t servlen, int flags );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2><span id="高级-io-函数">高级 I/O 函数</span></h2><p>讨论和网络编程相关的几个，这些函数大致分为三类: 用于创建文件描述符的函数，包括pipe、dup/dup2函数；用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和 tee函数；用于控制I/O行为和属性的函数，包括fcntl函数。</p>
<h3><span id="pipe-函数">pipe 函数</span></h3><p>创建管道，实现进程间通信。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字节流，拥有容量限制</p>
<p>此外，socket的基础API中有一个socketpair 函数。它能够方便地创建双向管道。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int socketpair(int domain, int type,int protocol,int fd[2] );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="dup-函数和-dup2-函数">dup 函数和 dup2 函数</span></h3><p>把标准输入重定向到一个文件，或把标准输出重定向到一个网络连接</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dup(int file_descriptor);
int dup2(int file_descriptor_one, int file_descriptor_two);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3><span id="readv-函数和-writev-函数">readv 函数和 writev 函数</span></h3><p>readv函数将数据从文件描述符读到分散的内存块中，即分散读;writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t readv(int fd, const struct iovec* vector, int count);
ssize_t writev(int fd, const struct iovec* vector, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3><span id="sendfile-函数">sendfile 函数</span></h3><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作)，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t sendfile(int our_fd, int in_fd, off_t* offset, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="mmap-函数和-munmap-函数">mmap 函数和 munmap 函数</span></h3><p>mmap 函数用于申请一段内存空间，可实现进程间共享内存， munmap释放mmap创建的这段内存空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *start, size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3><span id="splice-函数">splice 函数</span></h3><p>用于在两个文件描述符之间移动数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="tee函数">tee函数</span></h3><p>tee 函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="fcntl-函数">fcntl 函数</span></h3><p>filecontrol, 提供了对文件描述符的各种控制操作。</p>
<pre class="line-numbers language-none"><code class="language-none">int fcntl(int fd, int cmd, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2><span id="linux-服务器程序规范">Linux 服务器程序规范</span></h2><ul>
<li>后台进程形式运行</li>
<li>有一套日志系统，至少能输出日志到文件</li>
<li>一般以非 root 身份运行</li>
<li>可配置</li>
<li>服务器进程通常会在启动的时候生成一个 PID 文件 </li>
<li>考虑系统资源和限制</li>
</ul>
<h3><span id="日志">日志</span></h3><h4><span id="linux-系统日志">Linux 系统日志</span></h4><p>守护进程 rsyslogd</p>
<p>rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。</p>
<h4><span id="syslog-函数">syslog 函数</span></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void syslog(int priority, const char* message, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="用户信息">用户信息</span></h3><h4><span id="uid-euid-gid-和-egid">UID、EUID、GID 和 EGID</span></h4><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以root身份运行。下面这一组函数可以获取和设置当前进程的真实用户ID(UID)、有效用户ID （EUID)、真实组ID (GID）和有效组ID(EGID)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uid_t getuid();    /*获取真实用户ID */
uid_t geteuid ();  /*获取有效用户ID */
gid_t getgid ();  /*获取真实组ID*/
gid_t getegid () ; /*获取有效组ID*/
int setuid( uid_t uid ) ;
int seteuid(uid_t uid ) ;
int setgid( gid_t gid ) ;
int setegid(gid_t gid ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3><span id="进程间关系">进程间关系</span></h3><h4><span id="进程组">进程组</span></h4><p>Linux 下每个进程都隶属于一个进程组，获取指定进程的 PGID：</p>
<pre class="line-numbers language-none"><code class="language-none">pid_t getpgid(pid_t pid);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>设置 PGID：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int setpgid(pid_t pid, pid_t pgid);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4><span id="会话">会话</span></h4><p>一些关联的进程组将形成一个会话（session）</p>
<pre class="line-numbers language-none"><code class="language-none">pid_t setsid(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4><span id="用-ps-命令查看进程间关系">用 ps 命令查看进程间关系</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-o</span> pid, ppid, pgid, sid, <span class="token function">comm</span> <span class="token operator">|</span> <span class="token function">less</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3><span id="系统资源限制">系统资源限制</span></h3><p>Linux 上运行的程序都会受到资源限制的影响，比如物理设备限制(CPU数量、内存数量等)、系统策略限制（CPU时间等)，以及具体实现的限制（比如文件名的最大长度)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3><span id="改变工作目录和根目录">改变工作目录和根目录</span></h3><p>web 服务器的逻辑根目录并非文件系统的根目录”/“, 而是站点的根目录（对于Linux 的web服务器来说， 该目录一般是 /var/www/）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* getcwd(char* buf, size_t size); #获取进程当前工作目录
int chdir(const char* path); #改变进程工作目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3><span id="服务器程序后台化">服务器程序后台化</span></h3><p>让一个进程以守护进程的方式运行</p>
<h2><span id="高性能服务器程序框架">高性能服务器程序框架</span></h2><p>三个主要模块：I/O处理单元， 逻辑单元；存储单元。</p>
<h3><span id="服务器模型">服务器模型</span></h3><h4><span id="cs模型">C/S模型</span></h4><p>服务器启动，创建监听socket，bind()绑定到服务器感兴趣的端口，调用listen()等待客户连接。</p>
<p>服务器稳定运行，客户端connect()向服务器发起连接。</p>
<p>由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听。</p>
<h4><span id="p2p-模型">P2P 模型</span></h4><p>peer to peer</p>
<p>主机之间，难互相发现，通常有专门的发现服务器</p>
<h3><span id="服务器编程框架">服务器编程框架</span></h3><table>
<thead>
<tr>
<th>模块</th>
<th>单个服务器程序</th>
<th>服务器机群</th>
</tr>
</thead>
<tbody><tr>
<td>I/O处理单元</td>
<td>处理客户连接，读写网络程序</td>
<td>作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
<td>逻辑服务器</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>本地数据库、文件或缓存</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
<td>各服务器之间的永久TCP连接</td>
</tr>
</tbody></table>
<h3><span id="io-模型">I/O 模型</span></h3><p>socket 在创建时默认是阻塞的。针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。socket 的基础API中，可能被阻塞的系统调用包括accept、send、recv和 connect。</p>
<p>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</p>
<p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等)，才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p>
<p><strong>I/O复用</strong>是最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll和 epoll_wait。I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</p>
<p><strong>SIGIO信号</strong>也可以用来报告I/O事件。可以为一个目标文件描述符指定宿主进程，被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。</p>
<p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。</p>
<p><strong>异步I/O</strong>，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，不论I/O是否是阻塞，因为真正的读写操作已经由内核接管。</p>
<h3><span id="两种高效的事件处理模式">两种高效的事件处理模式</span></h3><p>服务器程序通常需要处理三类事件：I/O事件、信号、定时事件。</p>
<p>同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现Proactor模式。</p>
<h4><span id="reactor-模式">Reactor 模式</span></h4><p>使用同步IO模型（以epoll_wait为例）实现的Reactor模式的工作流程是:</p>
<ol>
<li>主线程往epoll 内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket 上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait 等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<h4><span id="proactor-模式">Proactor 模式</span></h4><p>将所有IO操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。</p>
<p>使用异步IO模型（以aio_read和aio_write为例）实现的Proactor模式的工.作流程是:</p>
<ol>
<li>主线程调用aio_read 函数向内核注册socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册)。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例)。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写人socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</li>
</ol>
<h3><span id="两种高效的并发模式">两种高效的并发模式</span></h3><p>I/O处理单元和多个逻辑单元之间协调完成任务的方法</p>
<p>注：在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（就绪事件/完成事件)，以及该由谁来完成IO读写（应用程序/内核)。在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行;“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</p>
<h4><span id="半同步半异步模式">半同步/半异步模式</span></h4><p>半同步/半异步模式中，同步线程用于处理客户逻辑; 异步线程用于处理I/O事件。</p>
<p>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量或信号量来随机地选择一个工作线程。</p>
<h4><span id="领导者追随者模式">领导者/追随者模式</span></h4><p>领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p>
<p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理IO事件，二者实现了并发。</p>
<h3><span id="高效的逻辑处理方式">高效的逻辑处理方式</span></h3><p>有限状态机，逻辑单元内部的一种高效的编程方法</p>
<h3><span id="提高服务器编程的其他建议">提高服务器编程的其他建议</span></h3><p>如何从“软环境”来提升服务器的性能？——服务器的“软环境”，一方面是指系统的软件资源，比如操作系统允许用户打开的最大文件描述符数量；另一方面指的就是服务器程序本身，即如何从编程的角度来确保服务器的性能。</p>
<h4><span id="池">池</span></h4><p>假设硬件资源充裕，空间换时间。</p>
<p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。</p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。</p>
<ul>
<li>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</li>
<li>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork 或pthread_create等函数来创建进程和线程。</li>
<li>连接池通常用于服务器或服务器机群的内部永久连接。比如，每个逻辑单元可能都需要频繁地访问本地的某个数据库。</li>
</ul>
<h4><span id="数据复制">数据复制</span></h4><p>高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心这些数据的内容，不需要对它们做任何分析。</p>
<p>此外，用户代码内部（不访问内核）的数据复制也是应该避免的。比如，当两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递。</p>
<h4><span id="上下文切换和锁">上下文切换和锁</span></h4><p>并发程序必须考虑上下文切换(context switch）的问题，即进程切换或线程切换导致的的系统开销。为每个客户连接都创建一个工作线程的服务器模型是不可取的。半同步/半异步模式是比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。当线程的数量不大于CPU的数目时，上下文的切换就不是问题了。</p>
<p>并发程序需要考虑的另外一个问题是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就应该避免使用锁。如果服务器必须使用锁，则可以考虑减小锁的粒度，比如使用读写锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存时，系统才必须去锁住这块区域。</p>
<h2><span id="io-复用">I/O 复用</span></h2>
        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link"><span class="top-box-text">Linux 网络编程基础 API</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">socket 地址 API</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">创建 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">命名 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">监听 socket</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">接受连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">发起连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">关闭连接</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">数据读写</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">带外标记</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">地址信息函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">socket 选项</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">网络信息 API</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link"><span class="top-box-text">高级 I&#x2F;O 函数</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">pipe 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">dup 函数和 dup2 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">readv 函数和 writev 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">sendfile 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">mmap 函数和 munmap 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">splice 函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">tee函数</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">fcntl 函数</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link"><span class="top-box-text">Linux 服务器程序规范</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">日志</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">用户信息</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">进程间关系</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">系统资源限制</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">改变工作目录和根目录</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">服务器程序后台化</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link"><span class="top-box-text">高性能服务器程序框架</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">服务器模型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">服务器编程框架</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">I&#x2F;O 模型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">两种高效的事件处理模式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">两种高效的并发模式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">高效的逻辑处理方式</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link"><span class="top-box-text">提高服务器编程的其他建议</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link"><span class="top-box-text">I&#x2F;O 复用</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/posts/3fc8ae63.html">
          <h3 class="post-title">
            下一篇：TCP/IP协议详解
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/Trea19" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

